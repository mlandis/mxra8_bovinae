
# branch-rate model
if (use_empirical_clock) {
    emp_clock_sd <- 0.5
    emp_clock_mean <- ln(0.001) - 0.5 * emp_clock_sd^2
    base_clock ~ dnLognormal( emp_clock_mean, emp_clock_sd )
} else {
    base_clock ~ dnLoguniform( min=1e-5, max=1e2 )
}
base_clock.setValue(0.1)

#ucln_sd ~ dnExp(1)
#ucln_sd.setValue(0.1)
ucln_sd <- 0.5
ucln_mean <- 0.0 - 0.5*ucln_sd^2

for (i in 1:n_branches) {
    branch_rate[i] ~ dnLognormal( ucln_mean, ucln_sd )
    branch_rate[i].setValue( 1. )
}

# concatenated molecular model
sdlog <- 0.5
meanlog <- 0.0 - 0.5*sdlog*sdlog

#k= 1
for (k in 1:n_part) {
#    for (j in 1:2) {
        # partition rate variation, lognormal
    part_rate[k] ~ dnLognormal( meanlog, sdlog )
    part_branch_rate[k] := base_clock * part_rate[k] * branch_rate

    # rate matrix, HKY
    bf[k] ~ dnDirichlet( [1,1,1,1] )
    kappa[k] ~ dnLognormal( meanlog, sdlog )
    Q[k] := fnHKY(bf[k], kappa[k])

    # site rate variation, +Gamma4
    alpha[k] ~ dnExp(1)
    site_rate[k] := fnDiscretizeGamma( alpha[k], alpha[k], numCats=4 )

    # phylogenetic substitution process
    seq[k] ~ dnPhyloCTMC( tree=phy,
                          Q=Q[k],
                          branchRates=part_branch_rate[k],
                          siteRates=site_rate[k],
                          type="DNA")
}

